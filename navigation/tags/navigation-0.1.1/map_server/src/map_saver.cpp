/*
 * map_saver
 * Copyright (c) 2008, Willow Garage, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <ORGANIZATION> nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/** @defgroup map_saver map_saver

@b map_saver dumps the map generated by a service to a file. It produces
two files, map.pgm and map.yaml that can then be given to
map_server.

<hr>

@section usage Usage
@verbatim
$ map_saver [-h] [-f <mapname>] [ROS remapping arguments]
@endverbatim

@b map_saver retrieves the map and writes the data to two files: the
occupancy data is written as a bitmap to <mapname>.pgm, and the metadata is
written in YAML to <mapname>.yaml.  The default <mapname> if "map".

Example, downloading map from slam_gmapping, which offers the @b dynamic_map service:
@verbatim
$ map_saver map:=dynamic_map
@endverbatim

<hr>

@section topic ROS services

Uses (name type):
- @b map nav_msgs/GetMap : map service.

 **/

#include <cstdio>
#include "ros/node.h"
#include "ros/console.h"
#include "nav_msgs/GetMap.h"
#include "LinearMath/btMatrix3x3.h"
#include "geometry_msgs/Quaternion.h"

using namespace std;
 
/**
 * @brief Map generation node.
 */
class MapGenerator 
{

  public:

    /**
     * @brief Create the map generation node and save the map.
     */
    MapGenerator(const std::string& mapname) 
    {
      ros::NodeHandle n;
      const static std::string servname = "map";
      ROS_INFO("Requesting the map from %s...", n.resolveName(servname).c_str());
      nav_msgs::GetMap::Request  req;
      nav_msgs::GetMap::Response resp;
      while(n.ok() && !ros::service::call(servname, req, resp))
      {
        ROS_WARN("request to %s failed; trying again...", n.resolveName(servname).c_str());
        usleep(1000000);
      }
      ROS_INFO("Received a %d X %d map @ %.3f m/pix",
               resp.map.info.width,
               resp.map.info.height,
               resp.map.info.resolution);


      std::string mapdatafile = mapname + ".pgm";
      ROS_INFO("Writing map occupancy data to %s", mapdatafile.c_str());
      FILE* out = fopen(mapdatafile.c_str(), "w");

      fprintf(out, "P5\n# CREATOR: Map_generator.cpp %.3f m/pix\n%d %d\n255\n",
              resp.map.info.resolution, resp.map.info.width, resp.map.info.height);
      for(unsigned int y = 0; y < resp.map.info.height; y++) {
        for(unsigned int x = 0; x < resp.map.info.width; x++) {
          unsigned int i = x + (resp.map.info.height - y - 1) * resp.map.info.width;
          if (resp.map.data[i] == 0) { //occ [0,0.1)
            fputc(254, out);
          } else if (resp.map.data[i] == +100) { //occ (0.65,1]
            fputc(000, out);
          } else { //occ [0.1,0.65]
            fputc(206, out);
          }
        }
      }

      fclose(out);


      std::string mapmetadatafile = mapname + ".yaml";
      ROS_INFO("Writing map occupancy data to %s", mapmetadatafile.c_str());
      FILE* yaml = fopen(mapmetadatafile.c_str(), "w");


      /*
resolution: 1
origin: [0.0, 0.0, 0.0]
#
vacant: [255]
occupied: [0]
interpolate: 0
unknown: [129]
       */

      geometry_msgs::Quaternion & orientation = resp.map.info.origin.orientation;
      btMatrix3x3 mat(btQuaternion(orientation.x, orientation.y, orientation.z, orientation.w));
      double yaw, pitch, roll;
      mat.getEulerZYX(yaw, pitch, roll);

      fprintf(yaml, "resolution: %f\norigin: [%f, %f, %f]\n#\nvacant: [254]\noccupied: [0]\ninterpolate: 0\nunknown: [206]\n",
              resp.map.info.resolution, resp.map.info.origin.position.x, resp.map.info.origin.position.y, yaw);

      fclose(yaml);

      ROS_INFO("Done\n");
    }
};

#define USAGE "Usage: \n" \
              "  map_saver -h\n"\
              "  map_saver [-f <mapname>] [ROS remapping args]"

int main(int argc, char** argv) 
{
  ros::init(argc, argv, "map_saver");
  std::string mapname = "map";

  for(int i=1; i<argc; i++)
  {
    if(!strcmp(argv[i], "-h"))
    {
      puts(USAGE);
      return 0;
    }
    else if(!strcmp(argv[i], "-f"))
    {
      if(++i < argc)
        mapname = argv[i];
      else
      {
        puts(USAGE);
        return 1;
      }
    }
    else
    {
      puts(USAGE);
      return 1;
    }
  }
  
  MapGenerator mg(mapname);

  return 0;
}


